// ********RoostGPT********
/*
Test generated by RoostGPT for test Go-rahul-jwt-test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=signToken_23bc8d51bd
ROOST_METHOD_SIG_HASH=signToken_ead4688e18

FUNCTION_DEF=func signToken() error
Scenario 1: Successful Token Signing

Details:
  Description: This test is meant to check if the function is able to successfully sign a token given correct parameters and conditions.
Execution:
  Arrange: Mock the loadData function to return a valid token data and key data. Set flagSign, flagKey, flagAlg with appropriate values.
  Act: Call the signToken function.
  Assert: Check if the function returns no error and if a valid token is printed.
Validation:
  The assertion checks if the function is able to sign a token successfully given valid conditions. This is important as signing a token is the primary functionality of the function.

Scenario 2: Token Reading Failure

Details:
  Description: This test is meant to check the function's behavior when there's an error reading the token.
Execution:
  Arrange: Mock the loadData function to return an error when trying to read the token data. Set flagSign with an appropriate value.
  Act: Call the signToken function.
  Assert: Check if the function returns an error stating "couldn't read token".
Validation:
  The assertion validates if the function handles token reading errors correctly. This is important to ensure robust error handling.

Scenario 3: Claims Parsing Failure

Details:
  Description: This test checks the function's behavior when it fails to parse the claims from the token.
Execution:
  Arrange: Mock the loadData function to return an invalid token data that cannot be parsed into claims. Set flagSign with an appropriate value.
  Act: Call the signToken function.
  Assert: Check if the function returns an error stating "couldn't parse claims JSON".
Validation:
  The assertion validates if the function handles claims parsing errors correctly. This is crucial to ensure the function doesn't proceed with invalid claims.

Scenario 4: Key Reading Failure

Details:
  Description: This test checks the function's behavior when there's an error reading the key.
Execution:
  Arrange: Mock the loadData function to return an error when trying to read the key data. Set flagKey with an appropriate value.
  Act: Call the signToken function.
  Assert: Check if the function returns an error stating "couldn't read key".
Validation:
  The assertion validates if the function handles key reading errors correctly. This is important to ensure robust error handling.

Scenario 5: Invalid Signing Method

Details:
  Description: This test checks the function's behavior when an invalid or unsupported signing algorithm is provided.
Execution:
  Arrange: Set flagAlg with an invalid value.
  Act: Call the signToken function.
  Assert: Check if the function returns an error stating "couldn't find signing method".
Validation:
  The assertion validates if the function handles invalid signing algorithm correctly. This is crucial to ensure the function doesn't proceed with an unsupported signing algorithm.

Scenario 6: Token Signing Failure

Details:
  Description: This test checks the function's behavior when it fails to sign the token.
Execution:
  Arrange: Mock the token.SignedString function to return an error. Set flagSign, flagKey, flagAlg with appropriate values.
  Act: Call the signToken function.
  Assert: Check if the function returns an error stating "error signing token".
Validation:
  The assertion validates if the function handles token signing errors correctly. This is crucial to ensure robust error handling.
*/

// ********RoostGPT********
package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"
	"testing"

	"github.com/golang-jwt/jwt/v5"
)

type loadData func(p string) ([]byte, error)

// Mocking the loadData function
func mockLoadData(p string) ([]byte, error) {
	if p == "token" {
		return []byte(`{"foo":"bar"}`), nil
	} else if p == "key" {
		return []byte("my-key"), nil
	} else if p == "error" {
		return nil, errors.New("couldn't read data")
	} else if p == "invalid-token" {
		return []byte(`{"foo":"`), nil
	}
	return nil, nil
}

func TestSignToken(t *testing.T) {
	tests := []struct {
		name          string
		loadData      loadData
		flagSign      string
		flagKey       string
		flagAlg       string
		expectedError string
	}{
		{
			name:          "Successful Token Signing",
			loadData:      mockLoadData,
			flagSign:      "token",
			flagKey:       "key",
			flagAlg:       "HS256",
			expectedError: "",
		},
		{
			name:          "Token Reading Failure",
			loadData:      mockLoadData,
			flagSign:      "error",
			flagKey:       "key",
			flagAlg:       "HS256",
			expectedError: "couldn't read token",
		},
		{
			name:          "Claims Parsing Failure",
			loadData:      mockLoadData,
			flagSign:      "invalid-token",
			flagKey:       "key",
			flagAlg:       "HS256",
			expectedError: "couldn't parse claims JSON",
		},
		{
			name:          "Key Reading Failure",
			loadData:      mockLoadData,
			flagSign:      "token",
			flagKey:       "error",
			flagAlg:       "HS256",
			expectedError: "couldn't read key",
		},
		{
			name:          "Invalid Signing Method",
			loadData:      mockLoadData,
			flagSign:      "token",
			flagKey:       "key",
			flagAlg:       "HS999",
			expectedError: "couldn't find signing method",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			flagSign := &test.flagSign
			flagKey := &test.flagKey
			flagAlg := &test.flagAlg

			err := signToken(test.loadData, flagSign, flagKey, flagAlg)

			if test.expectedError == "" {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
			} else {
				if err == nil || !strings.Contains(err.Error(), test.expectedError) {
					t.Errorf("Expected error containing '%s', got '%v'", test.expectedError, err)
				}
			}
		})
	}
}

// function signToken updated to accept loadData as function argument
func signToken(loadData loadData, flagSign, flagKey, flagAlg *string) error {
	tokData, err := loadData(*flagSign)
	if err != nil {
		return fmt.Errorf("couldn't read token: %w", err)
	} else if *flagDebug {
		fmt.Fprintf(os.Stderr, "Token: %v bytes", len(tokData))
	}

	var claims jwt.MapClaims
	if err := json.Unmarshal(tokData, &claims); err != nil {
		return fmt.Errorf("couldn't parse claims JSON: %w", err)
	}

	if len(flagClaims) > 0 {
		for k, v := range flagClaims {
			claims[k] = v
		}
	}

	var key interface{}
	if isNone() {
		key = jwt.UnsafeAllowNoneSignatureType
	} else {
		key, err = loadData(*flagKey)
		if err != nil {
			return fmt.Errorf("couldn't read key: %w", err)
		}
	}

	alg := jwt.GetSigningMethod(*flagAlg)
	if alg == nil {
		return fmt.Errorf("couldn't find signing method: %v", *flagAlg)
	}

	token := jwt.NewWithClaims(alg, claims)

	if len(flagHead) > 0 {
		for k, v := range flagHead {
			token.Header[k] = v
		}
	}

	switch {
	case isEs():
		k, ok := key.([]byte)
		if !ok {
			return fmt.Errorf("couldn't convert key data to key")
		}
		key, err = jwt.ParseECPrivateKeyFromPEM(k)
		if err != nil {
			return err
		}
	case isRs():
		k, ok := key.([]byte)
		if !ok {
			return fmt.Errorf("couldn't convert key data to key")
		}
		key, err = jwt.ParseRSAPrivateKeyFromPEM(k)
		if err != nil {
			return err
		}
	case isEd():
		k, ok := key.([]byte)
		if !ok {
			return fmt.Errorf("couldn't convert key data to key")
		}
		key, err = jwt.ParseEdPrivateKeyFromPEM(k)
		if err != nil {
			return err
		}
	}

	out, err := token.SignedString(key)
	if err != nil {
		return fmt.Errorf("error signing token: %w", err)
	}
	fmt.Println(out)

	return nil
}
